#!/usr/bin/env node
var debug = require('debug')('MHA-new');
var app = require('../app');
var WebSocketServer = require('ws').Server;

app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});

var p2 = require('p2');
var ws = require('ws');

// Create a World
var world = new p2.World({
    doProfiling:true,                    // Enable stats
    gravity : [0,0],                   // Set gravity to -10 in y direction
    broadphase : new p2.SAPBroadphase(), // Broadphase algorithm
});

var players = [];

// To get the trajectories of the bodies,
// we must step the world forward in time.
// This is done using a fixed time step size.
var timeStep = 1 / 60; // seconds


var wss = new WebSocketServer({server: server});
wss.on('connection', function(ws) {

	console.log("length: ", players.length);

	ws.on('message', function(e){
	  	console.log(e);

	  	var parsedData = JSON.parse(e);

	  	console.log(parsedData.action);

	  	switch(parsedData.action){
	  		case "ping":
	  			console.log('Pong')
				sendExistingPlayers(ws);
	  			break;
	  		case "createPlayer":
	  			addPlayer(ws);
	  			break;
			case "move":
				console.log("RECIEVED TOKEN: ", parsedData.token);
	  			updatePlayerPosition(parsedData.direction, parsedData.token);
	  			break;
	  		default:
	  			console.log('Unknown action\n');

	  	}
	  	//console.log(players);
	});
});


setInterval(function(){

	// tp.rotateLeft(400);
	// tp.rotateRight(400);
	// tp.rotateThrust(400);
	// tp.rotateReverse(400);

    // The step method moves the bodies forward in time.
    world.step(timeStep);

    var parsedPlayers = [];
	for (var i = 0; i < players.length; i++) {
		parsedPlayers[i] = new TransferObject(players[i]);
	};

	var data = {
		action: "updatePlayers",
		players: parsedPlayers
	}
	broadcastData(data);

    // Print the circle position to console.
    // Could be replaced by a render call.
    
    // console.log("Player position x: " + tp.body.position[0] + " y: " + tp.body.position[1]);

   // console.log(tp.body.angle);

}, 1000 * timeStep);

function updatePlayerPosition(direction, token) {
	var p = players.filter(function(e){
		return e.token == token;
	});
	try{
		p = p[0];

		if(p === undefined){
			throw "OBJECT WITH TOKEN :" + token +" NOT FOUND!";
		}

		switch(direction){
			case "forward":
				p.thrust(400);
				break;
			case "reverse":
				p.reverse(400);
				break;
			case "left":
				p.rotateLeft(100);
				break;
			case "right":
				p.rotateRight(100);
				break;
			case "stop":
				p.setZeroRotation();
				break;
			default:
				console.log("Unknown direction");
		}
	}catch(e){
		console.log(e.message);
	}
}

function addPlayer(ws) {
	var player = new Player(ws);
	// players[player.id] = player;
	players.push(player);
	data = {
		action: 'playerAdded',
		playerData: new TransferObject(player),
		token: player.token
	}
	ws.send(JSON.stringify(data));

	data.action = "newPlayerConnected";
	broadcastData(data);

}

function sendExistingPlayers(ws){
	var parsedPlayers = [];
	for (var i = 0; i < players.length; i++) {
		parsedPlayers[i] = new TransferObject(players[i]);
	};

	data = {
		action: "loadExistingPlayers",
		players: parsedPlayers
	}
	ws.send(JSON.stringify(data));
}


function removePlayer(id) {
	console.log("Deleting player: " + id);
	var dp = players.filter(function(e){
		return e.id == id;
	});

	players.splice(players.indexOf(dp),1);

	var data = {
		action: "removePlayer",
		playerId: id
	};
	broadcastData(data);

}

function broadcastData(data) {

	for (var i = 0; i < wss.clients.length; i++) {
		try{
			var p = wss.clients[i];
			p.send(JSON.stringify(data));
		}catch(e){
			console.log("Index: " + i);
			console.log(e.message);
		}		
	};
}

Player = function(ws){
	this.body =  new p2.Body({ position: [Math.floor((Math.random() * 200) + 100), Math.floor((Math.random() * 200) + 100)], mass: 1 });
	this.force = [0,0];
	this.id = this.body.id;
	this.token = token();


	var shape = new p2.Rectangle(50, 50);
	this.body.addShape(shape);
	world.addBody(this.body);
	
	var playerId = this.id


	if(ws!=null){

		ws.on('close', function() {
			removePlayer(playerId);
		});

	}

	this.ws = ws;
}

Player.prototype = {

	thrust: function(speed){
     	var magnitude = this.pxmi(speed);
        var angle = this.body.angle + Math.PI / 2;
		

		// console.log(magnitude,this.body.angle,angle);
		// process.exit(1);


        this.force[0] += (magnitude * Math.cos(angle));
        this.force[1] += (magnitude * Math.sin(angle));

        this.body.force[0] = this.force[0]
        this.body.force[1] = this.force[1];

        // console.log("Movement stuff: ", this.body.force[0], this.body.force[1]);

	},

	reverse: function (speed) {

        var magnitude = this.pxmi(speed);
        var angle = this.body.angle + Math.PI / 2;
        

        // REALLY FAST ACCELERATION
        // this.force[0] -= (magnitude * Math.cos(angle));
        // this.force[1] -= (magnitude * Math.sin(angle));
        // this.body.force[0] = this.force[0]
        // this.body.force[1] = this.force[1];
        
        this.body.force[0] += (magnitude * Math.cos(angle));
        this.body.force[1] += (magnitude * Math.sin(angle));

    },

   	/**
    * This will rotate the Body by the given speed to the left (counter-clockwise).
    *
    * @param {number} speed - The speed at which it should rotate.
    */
    rotateLeft: function (speed) {

        this.body.angularVelocity = this.pxm(-speed);

    },

    /**
    * This will rotate the Body by the given speed to the left (clockwise).
    *
    * @param {number} speed - The speed at which it should rotate.
    */
    rotateRight: function (speed) {

        this.body.angularVelocity = this.pxm(speed);

    },


    /**
    * If this Body is dynamic then this will zero its angular velocity.
    *
    */
    setZeroRotation: function () {

        this.body.angularVelocity = 0;

    },

	pxmi: function (v) {
        return v * -0.05;
    },

    /**
    * Convert pixel value to p2 physics scale (meters).
    * By default Phaser uses a scale of 20px per meter.
    * If you need to modify this you can over-ride these functions via the Physics Configuration object.
    *
    * @param {number} v - The value to convert.
    * @return {number} The scaled value.
    */
    pxm: function (v) {

        return v * 0.05;

    }
};


function TransferObject(obj) {
	this.x = obj.body.position[0];
	this.y = obj.body.position[1];
	this.angle = obj.body.angle;
	this.id = obj.id;
}


var rand = function() {
    return Math.random().toString(36).substr(2);
};

var token = function() {
    return rand() + rand();
};


var tp = new Player(null);