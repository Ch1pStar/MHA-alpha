#!/usr/bin/env node
var debug = require('debug')('MHA-new');
var app = require('../app');
var WebSocketServer = require('ws').Server;
var http = require('http');

app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});

var p2 = require('p2');
var ws = require('ws');

// Create a World
var world = new p2.World({
	    doProfiling:true,                    // Enable stats
	    gravity : [0,0],                   // Set gravity to -10 in y direction
	    broadphase : new p2.SAPBroadphase(), // Broadphase algorithm
	});
var map;
var mapData = [];
var players = [];
var options = {
	host: 'localhost',
	port: 3000,
	path: '/simple_assets/tellmeursecrets.json',
	method: 'GET'
};

// To get the trajectories of the bodies,
// we must step the world forward in time.
// This is done using a fixed time step size.
var timeStep = 1 / 60; // seconds

var wss = new WebSocketServer({server: server});
wss.on('connection', function(ws) {

	ws.send(JSON.stringify({action: 'init',mapUrl: options.path}));
	console.log("length: ", players.length);

	ws.on('message', function(e){
	  	// console.log(e);

	  	var parsedData = JSON.parse(e);

	  	// console.log(parsedData.action);

	  	switch(parsedData.action){
	  		case "ms":
	  			ws.send(JSON.stringify({action:"ms"}));
	  			break;	
	  		case "ping":
	  			console.log('Pong')
				sendExistingPlayers(ws);
	  			break;
	  		case "createPlayer":
	  			addPlayer(ws);
	  			break;
			case "move":
				// console.log("RECIEVED TOKEN: ", parsedData.token);
	  			updatePlayerPosition(parsedData.direction, parsedData.token);
	  			break;
	  		default:
	  			console.log('Unknown action\n');

	  	}
	  	//console.log(players);
	});
});



var req = http.request(options, function(res) {

	res.setEncoding('utf8');		
	res.on('data', function (chunk) {
		map = JSON.parse(chunk);
	});

	res.on('end', function(){
		// console.log(JSON.stringify(map));
		data = map.layers[0].data;
		var tileWidth = map.tilewidth;
		var tileHeight = map.tileheight;
		var mapWidth = map.layers[0].width; //tiles per row
		var xIndex = tileWidth/2;
		var yIndex = tileHeight/2;
		for (var i = 0; i < data.length; ) {
			var tile = data[i];
			if(tile!=0){
				console.log(i);
				console.log("Found a tile at: %s %s", xIndex, yIndex);
					var tileBody =  new p2.Body({ position: [xIndex, yIndex], mass: 0 });
					var tileShape = new p2.Rectangle(tileWidth, tileHeight);
					tileBody.addShape(tileShape);
					world.addBody(tileBody);
					mapData.push([xIndex, yIndex]);
					console.log("Pos: %s %s", tileBody.position[0], tileBody.position[1]);
			}
			i++;
			if(i>0 && i%20==0){
				yIndex += tileHeight;
				xIndex = tileWidth/2;
			}else{
				xIndex += tileWidth;
			}
		
		};
		startGameLoop();
	});
});

req.on('error', function(e) {
  console.log('problem with request: ' + e.message);
});
req.end();

function startGameLoop() {

	setInterval(function(){

		// tp.rotateLeft(400);
		// tp.rotateRight(400);
		// tp.rotateThrust(400);
		// tp.rotateReverse(400);

	    // The step method moves the bodies forward in time.
	    // 
	   
	    var parsedPlayers = [];
		for (var i = 0; i < players.length; i++) {
			parsedPlayers[i] = new TransferObject(players[i]);
		};

		var data = {
			action: "updatePlayers",
			players: parsedPlayers
		}
		broadcastData(data);


	    // Print the circle position to console.
	    // Could be replaced by a render call.
	    
	    try{
		    player = players[0];
		    // console.log("Player position x: " + player.body.position[0] + " y: " + player.body.position[1]+" angle: " + player.body.angle);
		}catch(e){
			console.log(e.message);
		}

	   // console.log(tp.body.angle);

	}, 1000 * timeStep);


	setInterval(function(){
	    world.step(timeStep);
	}, 1000 * timeStep);
	
}



function updatePlayerPosition(direction, token) {
	var p = players.filter(function(e){
		return e.token == token;
	});
	try{
		p = p[0];

		if(p === undefined){
			throw "OBJECT WITH TOKEN :" + token +" NOT FOUND!";
		}

		switch(direction){
			case "forward":
				p.thrust(400);
				break;
			case "reverse":
				p.reverse(400);
				break;
			case "left":
				p.rotateLeft(100);
				break;
			case "right":
				p.rotateRight(100);
				break;
			case "stop":
				p.setZeroRotation();
				break;
			default:
				console.log("Unknown direction");
		}
	}catch(e){
		console.log(e.message);
	}
}

function addPlayer(ws) {
	var player = new Player(ws);
	// players[player.id] = player;
	players.push(player);
	data = {
		action: 'playerAdded',
		playerData: new TransferObject(player),
		token: player.token
	}
	ws.send(JSON.stringify(data));

	data.action = "newPlayerConnected";
	broadcastData(data);


	broadcastData({action:'mapData',  mapData: mapData});

}

function sendExistingPlayers(ws){
	var parsedPlayers = [];
	for (var i = 0; i < players.length; i++) {
		parsedPlayers[i] = new TransferObject(players[i]);
	};

	data = {
		action: "loadExistingPlayers",
		players: parsedPlayers
	}
	ws.send(JSON.stringify(data));
}


function removePlayer(id) {
	console.log("Deleting player: " + id);
	var dp = players.filter(function(e){
		return e.id == id;
	});

	players.splice(players.indexOf(dp),1);

	var data = {
		action: "removePlayer",
		playerId: id
	};
	broadcastData(data);

}

function broadcastData(data) {

	for (var i = 0; i < wss.clients.length; i++) {
		try{
			var p = wss.clients[i];
			p.send(JSON.stringify(data));
		}catch(e){
			console.log("Index: " + i);
			console.log(e.message);
		}		
	};
}

Player = function(ws){
	this.body =  new p2.Body({ position: [Math.floor((Math.random() * 200) + 100), Math.floor((Math.random() * 200) + 100)], mass: 5 });
	this.force = [0,0];
	this.id = this.body.id;
	this.token = token();


	var shape = new p2.Rectangle(29, 29);
	this.body.addShape(shape);
	world.addBody(this.body);
	
	var playerId = this.id


	if(ws!=null){

		ws.on('close', function() {
			removePlayer(playerId);
		});

	}

	this.ws = ws;
}

Player.prototype = {

	thrust: function(speed){
     	var magnitude = -speed;
        var angle = this.body.angle + Math.PI / 2;
		

		// console.log(magnitude,this.body.angle,angle);
		// process.exit(1);


        // this.force[0] += (magnitude * Math.cos(angle));
        // this.force[1] += (magnitude * Math.sin(angle));

        this.body.force[0] += Math.round(magnitude * Math.cos(angle));
        this.body.force[1] += Math.round(magnitude * Math.sin(angle));

	},

	reverse: function (speed) {

        var magnitude = -speed;
        var angle = this.body.angle + Math.PI / 2;
        

        // REALLY FAST ACCELERATION
        // this.force[0] -= (magnitude * Math.cos(angle));
        // this.force[1] -= (magnitude * Math.sin(angle));
        // this.body.force[0] = this.force[0]
        // this.body.force[1] = this.force[1];
        
        this.body.force[0] -= (magnitude * Math.cos(angle));
        this.body.force[1] -= (magnitude * Math.sin(angle));

    },

   	/**
    * This will rotate the Body by the given speed to the left (counter-clockwise).
    *
    * @param {number} speed - The speed at which it should rotate.
    */
    rotateLeft: function (speed) {

        this.body.angularVelocity = this.pxm(-speed);

    },

    /**
    * This will rotate the Body by the given speed to the left (clockwise).
    *
    * @param {number} speed - The speed at which it should rotate.
    */
    rotateRight: function (speed) {

        this.body.angularVelocity = this.pxm(speed);

    },


    /**
    * If this Body is dynamic then this will zero its angular velocity.
    *
    */
    setZeroRotation: function () {

        this.body.angularVelocity = 0;

    },

	pxmi: function (v) {
        return v * -0.05;
    },

    /**
    * Convert pixel value to p2 physics scale (meters).
    * By default Phaser uses a scale of 20px per meter.
    * If you need to modify this you can over-ride these functions via the Physics Configuration object.
    *
    * @param {number} v - The value to convert.
    * @return {number} The scaled value.
    */
    pxm: function (v) {

        return v * 0.05;

    },

    /**
    * Convert p2 physics value (meters) to pixel scale.
    * By default Phaser uses a scale of 20px per meter.
    * If you need to modify this you can over-ride these functions via the Physics Configuration object.
    *
    * @method Phaser.Physics.P2#mpx
    * @param {number} v - The value to convert.
    * @return {number} The scaled value.
    */
    mpx: function (v) {

        return v *= 20;

    },

    /**
    * Convert p2 physics value (meters) to pixel scale and inverses it.
    * By default Phaser uses a scale of 20px per meter.
    * If you need to modify this you can over-ride these functions via the Physics Configuration object.
    *
    * @method Phaser.Physics.P2#mpxi
    * @param {number} v - The value to convert.
    * @return {number} The scaled value.
    */
    mpxi: function (v) {

        return v *= -20;

    }
};


function TransferObject(obj) {
	this.x = obj.body.position[0];
	this.y = obj.body.position[1];
	this.angle = obj.mpx(obj.body.angle);
	this.p2Angle = obj.body.angle;
	this.id = obj.id;
	this.force = [obj.body.force[0], obj.body.force[1]];
	this.angularVelocity = obj.body.angularVelocity;

	// console.log(this.force);
}


var rand = function() {
    return Math.random().toString(36).substr(2);
};

var token = function() {
    return rand() + rand();
};


// var tp = new Player(null);



//always wrap input angle to -PI..PI



